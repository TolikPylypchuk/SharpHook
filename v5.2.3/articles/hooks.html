<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
      <title>Global Hooks | SharpHook </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="Global Hooks | SharpHook ">
      
      
      <link rel="icon" href="../favicon.ico">
      <link rel="stylesheet" href="../public/docfx.min.css">
      <link rel="stylesheet" href="../public/main.css">
      <meta name="docfx:navrel" content="../toc.html">
      <meta name="docfx:tocrel" content="toc.html">
      
      <meta name="docfx:rel" content="../">
      
      
      <meta name="docfx:docurl" content="https://github.com/TolikPylypchuk/SharpHook/blob/v5.2.3/docs/articles/hooks.md/#L1">
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">
  </head>

  <script type="module" src="./../public/docfx.min.js"></script>

  <script>
    const theme = localStorage.getItem('theme') || 'auto'
    document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
  </script>


  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../index.html">
            <img id="logo" class="svg" src="../logo.png" alt="SharpHook">
            SharpHook
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
              <form class="search" role="search" id="search">
                <i class="bi bi-search"></i>
                <input class="form-control" id="search-query" type="search" disabled="" placeholder="Search" autocomplete="off" aria-label="Search">
              </form>
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">
      <div class="toc-offcanvas">
        <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
          <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
          </div>
          <div class="offcanvas-body">
            <nav class="toc" id="toc"></nav>
          </div>
        </div>
      </div>

      <div class="content">
        <div class="actionbar">
          <button class="btn btn-lg border-0 d-md-none" style="margin-top: -.65em; margin-left: -.8em" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
            <i class="bi bi-list"></i>
          </button>

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="">
<h1 id="global-hooks">Global Hooks</h1>

<h2 id="the-interface">The Interface</h2>
<p>SharpHook provides the <code>SharpHook.IGlobalHook</code> interface along with two default implementations which you can use
to control the hook and subscribe to its events. This way is preferred to using native functions since it's more
convenient. Here's a basic usage example:</p>
<pre><code class="lang-C#">using SharpHook;

// ...

var hook = new TaskPoolGlobalHook();

hook.HookEnabled += OnHookEnabled;     // EventHandler&lt;HookEventArgs&gt;
hook.HookDisabled += OnHookDisabled;   // EventHandler&lt;HookEventArgs&gt;

hook.KeyTyped += OnKeyTyped;           // EventHandler&lt;KeyboardHookEventArgs&gt;
hook.KeyPressed += OnKeyPressed;       // EventHandler&lt;KeyboardHookEventArgs&gt;
hook.KeyReleased += OnKeyReleased;     // EventHandler&lt;KeyboardHookEventArgs&gt;

hook.MouseClicked += OnMouseClicked;   // EventHandler&lt;MouseHookEventArgs&gt;
hook.MousePressed += OnMousePressed;   // EventHandler&lt;MouseHookEventArgs&gt;
hook.MouseReleased += OnMouseReleased; // EventHandler&lt;MouseHookEventArgs&gt;
hook.MouseMoved += OnMouseMoved;       // EventHandler&lt;MouseHookEventArgs&gt;
hook.MouseDragged += OnMouseDragged;   // EventHandler&lt;MouseHookEventArgs&gt;

hook.MouseWheel += OnMouseWheel;       // EventHandler&lt;MouseWheelHookEventArgs&gt;

hook.Run();
// or
await hook.RunAsync();
</code></pre>
<p><code>IGlobalHook</code> contains separate events for every event type that can be raised by libuiohook. The sender of these
events is the <code>IGlobalHook</code> itself.</p>
<p>It also contains the <code>Run</code> and <code>RunAsync</code> methods which run the global hook. <code>Run</code> runs it on the current thread,
blocking it until the global hook is disposed. <code>RunAsync</code> runs the global hook in a non-blocking way and returns a
<code>Task</code> - this task is finished when the hook is destroyed. Since the underlying native API is blocking, the only way to
run the hook in a non-blocking way is to run it on a separate thread, and all default implementations do just that.</p>
<p>You can specify in the hook constructors whether <code>RunAsync</code> should create a background thread or not. Background threads
don't block the application from exiting if all other threads have finished executing. By default the created thread
will not be a background thread.</p>
<p>You can subscribe to events after the hook is started.</p>
<p>If you run the hook when it's already running, then an exception will be thrown. You can check whether a hook is running
using its <code>IsRunning</code> property.</p>
<p><code>IGlobalHook</code> extends <code>IDisposable</code>. When you call the <code>Dispose</code> method on a hook, it's destroyed. The contract of
the interface is that once a hook has been destroyed, it cannot be started again - you'll have to create a new instance.
Calling <code>Dispose</code> when the hook is not running is safe - it just won't do anything (other than marking the instance as
disposed). You can check whether the hook is disposed using the <code>IsDisposed</code> property.</p>
<p>The <code>HookEnabled</code> event is raised once when the <code>Run</code> or <code>RunAsync</code> method is called. The <code>HookDisabled</code> event is raised
once when the <code>Dispose</code> method is called.</p>
<p>Hook events are of type <code>HookEvent</code> or a derived type which contains more info. It's possible to suppress event
propagation by setting the <code>SuppressEvent</code> property to <code>true</code> inside the event handler. This must be done synchronously
and is only supported on Windows and macOS.</p>
<div class="IMPORTANT">
<h5>Important</h5>
<p>Always use one instance of <code>IGlobalHook</code> at a time in the entire application since they all must use
the same static method to set the hook callback for libuiohook, so there may only be one callback at a time.</p>
</div>
<h2 id="the-default-implementations">The Default Implementations</h2>
<p>SharpHook provides two implementations of <code>IGlobalHook</code>:</p>
<ul>
<li><p><code>SharpHook.SimpleGlobalHook</code> runs all of its event handlers on the same thread on which the hook itself runs. This
means that the handlers should generally be fast since they will block the hook from handling the events that follow if
they run for too long.</p>
</li>
<li><p><code>SharpHook.TaskPoolGlobalHook</code> runs all of its event handlers on other threads inside the default thread pool for
tasks. The parallelism level of the handlers can be configured. On backpressure it will queue the remaining handlers.
This means that the hook will be able to process all events. This implementation should be preferred to
<code>SimpleGlobalHook</code> except for very simple use-cases. But it has a downside - suppressing event propagation will be
ignored since event handlers are run on other threads.</p>
</li>
</ul>
<p>The library also provides the <code>SharpHook.GlobalHookBase</code> class which you can extend to create your own implementation
of the global hook. It calls the appropriate event handlers, and you only need to implement a strategy for dispatching
the events. It also contains a finalizer which will stop the global hook if this object is not reachable anymore.</p>

</article>

        <div class="contribution d-print-none">
          <a href="https://github.com/TolikPylypchuk/SharpHook/blob/v5.2.3/docs/articles/hooks.md/#L1" class="edit-link">Edit this page</a>
        </div>

        <div class="next-article d-print-none border-top" id="nextArticle"></div>

      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>

    <div class="container-xxl search-results" id="search-results"></div>

    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          <span>Created by <a href="https://tolik.io">Tolik Pylypchuk</a>. Docs made with <a href="https://dotnet.github.io/docfx">docfx</a></span>.
        </div>
      </div>
    </footer>
  </body>
</html>
