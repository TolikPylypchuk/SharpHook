<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Logging </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="Logging ">
    <meta name="generator" content="docfx 2.59.4.0">
    
    <link rel="shortcut icon" href="../favicon.ico">
    <link rel="stylesheet" href="../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../styles/docfx.css">
    <link rel="stylesheet" href="../styles/main.css">
    <meta property="docfx:navrel" content="../toc.html">
    <meta property="docfx:tocrel" content="toc.html">
    
    
    
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../index.html">
                <img id="logo" class="svg" src="../logo.png" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
<h1 id="logging">Logging</h1>

<p>libuiohook can log messages throughout its execution. By default the messages are not logged anywhere, but you can get
these logs by using <code>UioHook.SetLoggerProc</code>, or the <code>ILogSource</code> interface and its default implementation, <code>LogSource</code>.</p>
<p>libuiohook logs contain the log level (debug, info, warning, error), message format, and message arguments.</p>
<p>The message structure is the following:</p>
<pre><code>function [line]: message
</code></pre>
<p><code>function</code> is the function name in the libuiohook source code, and <code>line</code> is the source code line.</p>
<h2 id="using-high-level-types">Using High-Level Types</h2>
<p>The easiest way to subscribe to libuiohook's logs is to use the <code>LogSource</code> class and its interface - <code>ILogSource</code>. The
interface contains the <code>MessageLogged</code> event, and extends <code>IDisposable</code>. Calling the <code>Dispose</code> method will stop the log
source from receiving the logs. The <code>IsDisposed</code> property is also available.</p>
<p><code>LogSource</code> also contains the <code>MinLevel</code> property which can be set to filter log messages by level. It's not recommended
to use the debug level for long periods of time since a debug message is logged for every single input event.</p>
<p>Here's a usage example:</p>
<pre><code>using SharpHook.Logging;
using SharpHook.Native;

// ...

var logSource = LogSource.Register(minLevel: LogLevel.Info);
logSource.MessageLogged += this.OnMessageLogged;

private void OnMessageLogged(object? sender, LogEventArgs e) =&gt;
    this.logger.Log(this.AdaptLogLevel(e.LogEntry.Level), e.LogEntry.FullText);
</code></pre>
<p>You can get an instance of <code>LogSource</code> by using the static <code>Register</code> method.</p>
<p><strong>Important</strong>: Always use one instance of <code>LogSource</code> at a time in the entire application since they all must use
the same static method to set the log callback for libuiohook, and there may only be one callback at a time.</p>
<p>The <code>MessageLogged</code> event contains event args of type <code>LogEventArgs</code> which contains just one property of type
<code>LogEntry</code>. This class contains the actual log message.</p>
<p>The simplest way to use <code>LogEntry</code> is to use its <code>Level</code> and <code>FullText</code> properties. <code>FullText</code> is created using the log
message format and arguments so you don't have to do it yourself.</p>
<p>You can dispose of a log source to stop receiving libuiohook messages. You should keep a reference to an instance of
<code>LogSource</code> when you use it since it will stop receiving messages when garbage collector deletes it, to avoid memory
leaks.</p>
<p>SharpHook.Reactive contains the <code>IReactiveLogSource</code> and its implementation - <code>ReactiveLogSourceAdapter</code>. Here's a
usage example:</p>
<pre><code>using SharpHook.Logging;
using SharpHook.Native;
using SharpHook.Reactive.Logging;

// ...

var logSource = LogSource.Register(minLevel: LogLevel.Info);
var reactiveLogSource = new ReactiveLogSourceAdapter(logSource);
reactiveLogSource.MessageLogged.Subscribe(this.OnMessageLogged);
</code></pre>
<p><code>IReactiveLogSource</code> is basically the same as <code>ILogSource</code>, but <code>MessageLogged</code> is an observable of <code>LogEntry</code> instead
of an event. <code>ReactiveLogSourceAdapter</code> adapts an <code>ILogSource</code> to the <code>IReactiveLogSource</code> interface.</p>
<h2 id="using-the-low-level-functionality">Using the Low-Level Functionality</h2>
<p>The logging functionality works by using <code>UioHook.SetLoggerProc</code>. This method sets the log callback - a delegate of
type <code>LoggerProc</code>, which will be called to log the messages of libuiohook. <code>LoggerProc</code> receives the log level, a
pointer to the message format, and a pointer the message arguments. It also receives a pointer to user-supplied data
(which is set in the <code>UioHook.SetLoggerProc</code>), but you shouldn't ever use that.</p>
<p>It is highly recommended to use <code>LogEntryParser</code> in order to create a log entry out of the pointers to the message
format and arguments. This way you won't have to handle these pointers directly. The problem with handling them directly
is that the log callback receives a variable number of arguments. In C# you can use the <code>params</code> keyword for that, but
native functions do that in an entirely different way, and .NET doesn't have a default way to handle that (there is an
undocumented <code>__arglist</code> keyword, but it can't be used in delegates and callbacks). <code>LogEntryParser</code> handles all that -
its code is based on the log handling code of <a href="https://github.com/videolan/libvlcsharp">LibVLCSharp</a>. Basically it calls
the native <code>vsprintf</code> function from the C runtime and lets it deal with formatting the log message with native variable
arguments. It then parses the log message and the log format and extracts the arguments.</p>
<p>If you want to use your own callback then its form should be the following:</p>
<pre><code>private readonly LogEntryParser parser = new();

// ...

private void OnLog(LogLevel level, IntPtr userData, IntPtr format, IntPtr args)
{
    // Filter by log level if needed

    var logEntry = this.parser.ParseNativeLogEntry(level, format, args);

    // Handle the log entry instead of the native format and arguments
}
</code></pre>
<p><strong>Note</strong>: Since <code>LogEntryParser</code> uses the C runtime, it requires the Visual C++ Redistributable package on Windows,
unlike the rest of SharpHook. If you don't want your app to be dependent on this package, then you can use the
<code>EmptyLogSource</code> class instead of <code>LogSource</code> in release builds of your app. <code>EmptyLogSource</code> implements <code>ILogSource</code>,
but never raises the <code>MessageLogged</code> event and doesn't subscribe to libuiohook logs.</p>
<h2 id="advanced-usage">Advanced Usage</h2>
<p>If you use structured logging then you may want to use the message format and arguments directly, instead of using the
formatted result. <code>LogEntry</code> contains properties which can help you with that:</p>
<ul>
<li><code>Format</code> - the format of the log message which can be passed to <code>String.Format</code>.</li>
<li><code>RawFormat</code> - the raw native format of the log message (which uses argument placeholders for C's <code>printf</code> function).</li>
<li><code>Arguments</code> - the strongly-typed arguments of the log message.</li>
<li><code>RawArguments</code> - the arguments of the log message as they appear in the formatted log message.</li>
<li><code>ArgumentPlaceholders</code> - the placeholders extracted from the native log format (e.g. <code>%d</code> for a number).</li>
</ul>
<p><code>String.Format(entry.Format, entry.RawAguments.ToArray())</code> is equal to <code>entry.FullText</code>.</p>
<p><code>String.Format(entry.Format, entry.Aguments.ToArray())</code> is not necessarily equal to <code>entry.FullText</code> since some
formatting information is discarded, but using <code>Arguments</code> instead of <code>RawArguments</code> is better suited for structured
logging.</p>
<p><code>Arguments</code> contains parsed message arguments which can be of one of the types listed below, according to the argument
placeholders. Only the specifier and length are considered (see the C's <code>printf</code> docs for reference).</p>
<table>
  <tr>
    <th>Type</th>
    <th>Placeholder</th>
  </tr>
  <tr>
    <td><code>int</code></td>
    <td><code>%d</code>, <code>%i</code></td>
  </tr>
  <tr>
    <td><code>sbyte</code></td>
    <td><code>%hhd</code>, <code>%hhi</code></td>
  </tr>
  <tr>
    <td><code>short</code></td>
    <td><code>%hd</code>, <code>%hi</code></td>
  </tr>
  <tr>
    <td><code>long</code></td>
    <td>
        <code>%ld</code>, <code>%li</code>, <code>%lld</code>, <code>%lli</code>, <code>%jd</code>, <code>%ji</code>
    </td>
  </tr>
  <tr>
    <td><code>uint</code></td>
    <td><code>%u</code>, <code>%o</code>, <code>%x</code>, <code>%X</code></td>
  </tr>
  <tr>
    <td><code>byte</code></td>
    <td><code>%hhu</code>, <code>%hho</code>, <code>%hhx</code>, <code>%hhX</code></td>
  </tr>
  <tr>
    <td><code>ushort</code></td>
    <td><code>%hu</code>, <code>%ho</code>, <code>%hx</code>, <code>%hX</code></td>
  </tr>
  <tr>
    <td><code>ulong</code></td>
    <td>
        <code>%lu</code>, <code>%lo</code>, <code>%lx</code>, <code>%lX</code>, <code>%llu</code>, <code>%llo</code>,
        <code>%llx</code>, <code>%llX</code>, <code>%ju</code>, <code>%jo</code>, <code>%jx</code>, <code>%jX</code>
    </td>
  </tr>
  <tr>
    <td><code>double</code></td>
    <td><code>%f</code>, <code>%F</code>, <code>%e</code>, <code>%E</code>, <code>%g</code>, <code>%G</code></td>
  </tr>
  <tr>
    <td><code>decimal</code></td>
    <td><code>%Lf</code>, <code>%LF</code>, <code>%Le</code>, <code>%LE</code>, <code>%Lg</code>, <code>%LG</code></td>
  </tr>
  <tr>
    <td><code>char</code></td>
    <td><code>%c</code></td>
  </tr>
  <tr>
    <td><code>IntPtr</code></td>
    <td><code>%p</code></td>
  </tr>
  <tr>
    <td><code>string</code></td>
    <td>Any other placeholder, including <code>%s</code></td>
  </tr>
</table>
<p>The <code>%a</code>, <code>%A</code>, and <code>%n</code> specifiers are not supported, as well as length <code>z</code> and <code>t</code>.</p>
<p><code>LogEntry</code> also contains the <code>Function</code> and <code>SourceLine</code> properties. These are the first two arguments of the log
message - the function name in the libuiohook source code, and the source code line.</p>
<p>Next article: <a href="migration.html">Migration Guide</a>.</p>
</article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                  <li>
                    <a href="https://github.com/TolikPylypchuk/SharpHook/blob/master/docs/articles/logging.md/#L1" class="contribution-link">Improve this Doc</a>
                  </li>
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
                <h5>In This Article</h5>
                <div></div>
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            
            <span>Generated by <strong>DocFX</strong></span>
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../styles/docfx.js"></script>
    <script type="text/javascript" src="../styles/main.js"></script>
  </body>
</html>
